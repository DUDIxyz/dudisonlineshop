<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>STARTSEITE // SCROLL ENGINE ONLINE</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
:root {
  --bg1: #050505;
  --bg2: #0f1020;
  --accent: #7cffd4;
  --accent2: #ff6ad5;
}

html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  background: black;
  color: white;
  font-family: monospace;
  overflow-x: hidden;
}

body {
  min-height: 1200vh; /* ewig scrollen */
}

/* =========================
   FIXED BACKGROUND LAYERS
========================= */

#bg-gradient {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at center, #111 0%, #000 60%);
  z-index: -5;
  transition: filter 0.2s linear;
}

#noise {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: -4;
  background-image:
    repeating-linear-gradient(
      0deg,
      rgba(255,255,255,0.03),
      rgba(255,255,255,0.03) 1px,
      transparent 1px,
      transparent 2px
    );
  mix-blend-mode: overlay;
}

/* =========================
   CANVAS
========================= */

canvas {
  position: fixed;
  inset: 0;
  z-index: -3;
}

/* =========================
   HERO
========================= */

.hero {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  pointer-events: none;
}

.hero h1 {
  font-size: clamp(2rem, 6vw, 6rem);
  letter-spacing: 0.2em;
  text-transform: uppercase;
  animation: flicker 4s infinite;
}

.hero p {
  opacity: 0.6;
}

@keyframes flicker {
  0% { opacity: 1; }
  2% { opacity: 0.2; }
  4% { opacity: 1; }
  100% { opacity: 1; }
}

/* =========================
   SCROLL SECTIONS (FAKE)
========================= */

.section {
  position: relative;
  height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 3rem;
  opacity: 0.05;
  transition: opacity 0.3s;
}

.section.active {
  opacity: 1;
}

.parallax {
  position: absolute;
  font-size: 10vw;
  opacity: 0.08;
  white-space: nowrap;
}

/* =========================
   GLITCH TEXT
========================= */

.glitch {
  position: relative;
}

.glitch::before,
.glitch::after {
  content: attr(data-text);
  position: absolute;
  left: 0;
}

.glitch::before {
  color: var(--accent);
  transform: translate(2px, -2px);
  opacity: 0.6;
}

.glitch::after {
  color: var(--accent2);
  transform: translate(-2px, 2px);
  opacity: 0.6;
}

/* =========================
   FOOTER ZONE
========================= */

#end {
  height: 200vh;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2rem;
  opacity: 0.4;
}
</style>
</head>

<body>

<div id="bg-gradient"></div>
<div id="noise"></div>
<canvas id="canvas"></canvas>

<div class="hero">
  <h1 class="glitch" data-text="UNDER CONSTRUCTION">UNDER CONSTRUCTION</h1>
  <p>scroll to destabilize reality</p>
</div>

<!-- FAKE CONTENT -->
<div class="section"><div class="parallax">SYSTEM INITIALIZING</div></div>
<div class="section"><div class="parallax">SCROLL DATA STREAM</div></div>
<div class="section"><div class="parallax">LAYERS DESYNCING</div></div>
<div class="section"><div class="parallax">NO FINAL STATE</div></div>
<div class="section"><div class="parallax">WORK IN PROGRESS</div></div>

<div id="end">you were never supposed to reach this</div>

<script>
/* =========================
   CANVAS PARTICLES
========================= */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let w, h;
function resize() {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

const particles = Array.from({ length: 120 }, () => ({
  x: Math.random() * w,
  y: Math.random() * h,
  r: Math.random() * 2 + 0.5,
  vx: (Math.random() - 0.5) * 0.3,
  vy: (Math.random() - 0.5) * 0.3
}));

function draw() {
  ctx.clearRect(0, 0, w, h);
  for (const p of particles) {
    p.x += p.vx;
    p.y += p.vy;

    if (p.x < 0 || p.x > w) p.vx *= -1;
    if (p.y < 0 || p.y > h) p.vy *= -1;

    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(255,255,255,0.5)";
    ctx.fill();
  }
  requestAnimationFrame(draw);
}
draw();

/* =========================
   SCROLL ENGINE
========================= */
const sections = document.querySelectorAll(".section");
const bg = document.getElementById("bg-gradient");

window.addEventListener("scroll", () => {
  const scroll = window.scrollY;
  const progress = scroll / (document.body.scrollHeight - innerHeight);

  bg.style.filter = `hue-rotate(${progress * 360}deg) blur(${progress * 8}px)`;

  sections.forEach((sec, i) => {
    const start = i * innerHeight;
    const end = start + innerHeight;
    sec.classList.toggle("active", scroll > start && scroll < end);

    const para = sec.querySelector(".parallax");
    if (para) {
      para.style.transform = `translateX(${scroll * 0.05 * (i % 2 ? -1 : 1)}px)`;
    }
  });

  // micro glitch
  if (Math.random() < 0.01) {
    document.body.style.filter = "invert(1)";
    setTimeout(() => document.body.style.filter = "", 50);
  }
});
</script>
<!-- =========================
     SCROLL TERMINAL FULL GLITCH
========================= -->
<style>
#terminal {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  max-height: 40vh;
  background: rgba(0,0,0,0.85);
  color: #7cffd4;
  font-family: monospace;
  font-size: 14px;
  padding: 10px;
  box-sizing: border-box;
  transform: translateY(100%);
  transition: transform 0.4s ease;
  z-index: 999;
  display: flex;
  flex-direction: column;
}
#terminal.active { transform: translateY(0); }

#terminal-output {
  flex: 1;
  overflow-y: auto;
  white-space: pre-wrap;
}

#terminal-input-line { display: flex; }
#terminal-input-line span {
  margin-right: 6px;
  animation: blink 1s step-start infinite;
}

#terminal-input {
  background: transparent;
  border: none;
  outline: none;
  color: #7cffd4;
  font-family: monospace;
  font-size: 14px;
  flex: 1;
}

@keyframes blink {
  0%, 50%, 100% { opacity: 1; }
  25%, 75% { opacity: 0; }
}

@media (max-width: 600px) {
  #terminal { font-size: 13px; max-height: 50vh; }
}
</style>

<div id="terminal">
  <div id="terminal-output">
SYSTEM READY  
type <help>
  </div>
  <div id="terminal-input-line">
    <span>&gt;</span>
    <input id="terminal-input" autocomplete="off" />
  </div>
</div>

<script>
const terminal = document.getElementById("terminal");
const output = document.getElementById("terminal-output");
const input = document.getElementById("terminal-input");

// minimal commands + secret + navigation
const commands = {
  help: () => `
available commands:
help
whoami
status
clear
exit
secret
go [page]
`,
  whoami: () => "you are early.",
  status: () => "under construction.\nprogress undefined.",
  clear: () => { output.textContent=""; return ""; },
  exit: () => "there is no exit.",
  secret: () => "ðŸŽ‰ SECRET UNLOCKED: hidden layer revealed!",
  "go startseite": () => { window.location.href="startseite.html"; },
  "go index": () => { window.location.href="index.html"; },
  "go kontakt": () => { window.location.href="kontakt.html"; }
};

// aliases
commands.s = commands["go startseite"];
commands.i = commands["go index"];

// typewriter optional
function printAnimated(text){
  let i=0;
  const interval = setInterval(()=>{
    output.textContent += text[i];
    output.scrollTop = output.scrollHeight;
    i++;
    if(i>=text.length) clearInterval(interval);
  }, 20);
}

function print(text){
  if(!text) return;
  output.textContent += "\n" + text;
  output.scrollTop = output.scrollHeight;
}

// handle enter
input.addEventListener("keydown", e => {
  if(e.key==="Enter"){
    const val = input.value.trim();
    print("> " + val);
    if(commands[val]) commands[val]();
    else print("command not found");
    input.value="";
  }
});

// scroll trigger + glitch + text distortion
window.addEventListener("scroll", ()=>{
  const progress = window.scrollY / (document.body.scrollHeight - window.innerHeight);

  // show/hide terminal
  if(progress > 0.35) terminal.classList.add("active");
  else terminal.classList.remove("active");

  // glitch intensity
  if(progress > 0.35){
    // color glitch
    if(Math.random() < 0.05 + progress*0.05){
      terminal.style.color = `hsl(${Math.random()*360}, 80%, 65%)`;
      setTimeout(()=>terminal.style.color="#7cffd4", 120);
    }
    // text distortion: randomly replace chars in output
    let txt = output.textContent.split("");
    for(let i=0; i<txt.length; i++){
      if(Math.random() < 0.01*progress*10){
        const charCode = 33 + Math.floor(Math.random()*94);
        txt[i] = String.fromCharCode(charCode);
      }
    }
    output.textContent = txt.join("");
    output.scrollTop = output.scrollHeight;
  }
});

// autofocus when terminal slides in
terminal.addEventListener('transitionend', () => {
  if(terminal.classList.contains("active")) input.focus();
});
</script>


</body>
</html>
